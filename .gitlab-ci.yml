# GitLab CI/CD Pipeline for Hackathon Project
# ============================================

stages:
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  FRONTEND_IMAGE: $CI_REGISTRY_IMAGE/frontend
  BACKEND_IMAGE: $CI_REGISTRY_IMAGE/backend

# ============================================
# CACHE CONFIGURATION
# ============================================
.node_cache: &node_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-node
    paths:
      - NextFrontend/node_modules/
      - NextFrontend/.next/cache/

.python_cache: &python_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-python
    paths:
      - .cache/pip
      - .venv/

# ============================================
# TEST STAGE
# ============================================
test-frontend:
  stage: test
  image: node:20-alpine
  <<: *node_cache
  before_script:
    - cd NextFrontend
    - npm ci
  script:
    - npm run lint
    - npm run test -- --coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: NextFrontend/coverage/cobertura-coverage.xml

test-backend:
  stage: test
  image: python:3.12-slim
  services:
    - name: postgres:16-alpine
      alias: postgres
    - name: redis:7-alpine
      alias: redis
  <<: *python_cache
  variables:
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
    # Database bağlantısı - service container'ına işaret eder
    POSTGRES_SERVER: "postgres"
    POSTGRES_PORT: "5432"
    POSTGRES_USER: "postgres"
    POSTGRES_PASSWORD: "postgres"
    POSTGRES_DB: "hackathon_app"
    # Redis bağlantısı
    REDIS_URL: "redis://redis:6379/0"
    CELERY_BROKER_URL: "redis://redis:6379/1"
    CELERY_RESULT_BACKEND: "redis://redis:6379/2"
    # Uygulama ayarları (GitLab Variables'tan da gelebilir)
    PROJECT_NAME: "Hackathon API"
    API_V1_STR: "/api/v1"
    SECRET_KEY: "ci-test-secret-key"
    DEBUG: "false"
  before_script:
    - cd hackathon_backend
    - pip install uv
    - uv sync
    # Wait for postgres to be ready and create test database
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - PGPASSWORD=postgres psql -h postgres -U postgres -c "CREATE DATABASE hackathon_test;" || true
    - PGPASSWORD=postgres psql -h postgres -U postgres -c "CREATE DATABASE hackathon_app;" || true
  script:
    - uv run pytest --cov=app --cov-report=xml
  coverage: '/TOTAL.*\s+(\d+%)/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: hackathon_backend/coverage.xml

# ============================================
# BUILD STAGE
# ============================================
build-frontend:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    # Default values - override these in GitLab CI/CD Variables
    NEXT_PUBLIC_APP_NAME: "Hackathon App"
    NEXT_PUBLIC_APP_ENV: "production"
    # Use backend LoadBalancer IP - update if IP changes
    NEXT_PUBLIC_API_BASE_URL: "http://34.9.11.2/api"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      docker build \
        --build-arg NEXT_PUBLIC_APP_NAME="$NEXT_PUBLIC_APP_NAME" \
        --build-arg NEXT_PUBLIC_APP_ENV="$NEXT_PUBLIC_APP_ENV" \
        --build-arg NEXT_PUBLIC_API_BASE_URL="$NEXT_PUBLIC_API_BASE_URL" \
        -t $FRONTEND_IMAGE:$CI_COMMIT_SHA \
        -t $FRONTEND_IMAGE:latest \
        ./NextFrontend
    - docker push $FRONTEND_IMAGE:$CI_COMMIT_SHA
    - docker push $FRONTEND_IMAGE:latest
  only:
    - main
    - develop
  needs:
    - job: test-frontend
      optional: true

build-backend:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $BACKEND_IMAGE:$CI_COMMIT_SHA -t $BACKEND_IMAGE:latest ./hackathon_backend
    - docker push $BACKEND_IMAGE:$CI_COMMIT_SHA
    - docker push $BACKEND_IMAGE:latest
  only:
    - main
    - develop
  needs:
    - job: test-backend
      optional: true

# ============================================
# DEPLOY STAGE
# ============================================
.deploy_template: &deploy_template
  stage: deploy
  image: google/cloud-sdk:alpine
  variables:
    GCP_PROJECT: "kobi-42"
    GCP_ZONE: "us-central1"
    GKE_CLUSTER: "hackathon-cluster"
  before_script:
    # Install kubectl
    - gcloud components install kubectl --quiet || true
    # Authenticate with GCP using Service Account
    - echo "Authenticating with GCP..."
    - gcloud auth activate-service-account --key-file="$GCP_SERVICE_ACCOUNT_KEY"
    - gcloud config set project $GCP_PROJECT
    # Get GKE cluster credentials
    - gcloud container clusters get-credentials $GKE_CLUSTER --region $GCP_ZONE --project $GCP_PROJECT
    # Verify connection
    - kubectl cluster-info
    # Replace image tags in manifests with actual image
    - sed -i "s|\${CI_REGISTRY_IMAGE}|$CI_REGISTRY_IMAGE|g" k8s/backend.yaml
    - sed -i "s|\${CI_REGISTRY_IMAGE}|$CI_REGISTRY_IMAGE|g" k8s/frontend.yaml
    - sed -i "s|\${CI_REGISTRY_IMAGE}|$CI_REGISTRY_IMAGE|g" k8s/celery.yaml
    - sed -i "s|:latest|:$CI_COMMIT_SHA|g" k8s/backend.yaml
    - sed -i "s|:latest|:$CI_COMMIT_SHA|g" k8s/frontend.yaml
    - sed -i "s|:latest|:$CI_COMMIT_SHA|g" k8s/celery.yaml

deploy-staging:
  <<: *deploy_template
  script:
    - kubectl apply -f k8s/namespace.yaml
    - kubectl apply -f k8s/configmap.yaml
    - kubectl apply -f k8s/secrets.yaml
    - kubectl apply -f k8s/postgres.yaml
    - kubectl apply -f k8s/redis.yaml
    - kubectl apply -f k8s/backend.yaml
    - kubectl apply -f k8s/frontend.yaml
    - kubectl apply -f k8s/celery.yaml
    - kubectl apply -f k8s/ingress.yaml
    - kubectl rollout status deployment/backend -n hackathon --timeout=300s
    - kubectl rollout status deployment/frontend -n hackathon --timeout=300s
  environment:
    name: staging
    url: https://staging.hackathon.example.com
  only:
    - develop
  needs:
    - build-frontend
    - build-backend

deploy-production:
  <<: *deploy_template
  script:
    - kubectl apply -f k8s/namespace.yaml
    - kubectl apply -f k8s/configmap.yaml
    - kubectl apply -f k8s/secrets.yaml
    - kubectl apply -f k8s/postgres.yaml
    - kubectl apply -f k8s/redis.yaml
    - kubectl apply -f k8s/backend.yaml
    - kubectl apply -f k8s/frontend.yaml
    - kubectl apply -f k8s/celery.yaml
    - kubectl apply -f k8s/ingress.yaml
    - kubectl rollout status deployment/backend -n hackathon --timeout=300s
    - kubectl rollout status deployment/frontend -n hackathon --timeout=300s
  environment:
    name: production
    url: https://hackathon.example.com
  only:
    - main
  when: manual # Requires manual approval for production
  needs:
    - build-frontend
    - build-backend

# ============================================
# CLEANUP (Optional)
# ============================================
cleanup-old-images:
  stage: deploy
  image: docker:24
  services:
    - docker:24-dind
  script:
    - echo "Cleaning up old images..."
    # Add image cleanup logic here if needed
  only:
    - main
  when: manual
